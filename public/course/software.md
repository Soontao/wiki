# 软件工程

## 第一章 概论

##### 软件

* 程序
* 数据
* 文档

##### 软件危机

在计算机软件的开发和维护过程中所遇到的一系列严重问题。 

##### 软件工程

将工程应用到软件

##### 软件工程三要素

* 工具
* 方法
* 过程

软件工程七原则

* 阶段性生命周期计划管理
* 持续验证
* 严格控制
* 现代工具
* 清晰责任分配
* 用更好更少的人
* 保持过程改进

## 第二章 过程模型



#### 瀑布模型

**瀑布模型适用于系统需求明确、技术成熟、工程管理较严格的场合。**

**缺点：**

各个阶段的划分完全固定，阶段之间产生大量的文档，极大地增加了工作量；

由于开发模型是线性的，用户只有等到整个过程的末期才能见到开发成果，从而增加了开发的风险；

早期的错误可能要等到开发后期的测试阶段才能发现，进而带来严重的后果。



#### 增量模型

从部分需求定义出发，先建立一个不完整的系统，通过测试运行这个系统取得经验和反馈，进一步使系统扩充和完善。

**构造小而可用的软件**

**优点：**

增量包概念的引入，以及它不需要提供完整的需求。只要有一个增量包出现，开发就可以进行。

在项目的初始阶段不需要投入太多的人力资源。

增量可以有效地管理技术风险。

**缺点：**

每个增量必须提供一些系统功能，这使得开发者很难根据客户需求给出大小适合的增量。 





#### 原型模型

实现一个可实际运行的系统初步模型，供开发人员和用户进行交流和评审，以便较准确获得用户的需求，然后采用逐步求精方法使原型逐步完善。

**优点：**

开发效率高，原型使总的开发费用降低，时间缩短，开发者与用户交流直观，可以澄清模糊需求，调动用户的积极性，能及早地暴露系统实施后潜在的一些问题。

**缺点：**

产品原型在一定程度上限制了开发人员的创新，没有考虑软件的整体质量和长期的可维护性，由于达不到质量要求产品可能被抛弃，而采用新的模型重新设计，相关利益者不会意识到质量问题，而使开发管理陷入失效。

设计者在质量和原型间有所折衷，会采用熟悉的工具和环境、低效的算法，一旦适应后，忘记初衷，造成质量问题。



#### 螺旋模型

**优点：**

支持用户需求的动态变化。

原型可看作形式的可执行的需求规格说明，易于为用户和开发人员共同理解，还可作为继续开发的基础，并为用户参与所有关键决策提供了方便。

螺旋模型特别强调原型的可扩充性和可修改性，原型的进化贯穿整个软件生存周期，这将有助于目标软件的适应能力。

引入一个非常严格的风险识别，风险分析和风险控制，它把软件项目分解成一个个小项目，每个小项目都标识一个或多个主要风险，直到所有的主要风险因素都被确定。

螺旋模型为项目管理人员及时调整管理决策提供了方便，进而可降低开发风险。

**缺点:**

如果每次迭代的效率不高，致使迭代次数过多，将会增加成本并推迟提交时间；

使用该模型需要有相当丰富的风险评估经验和专门知识，要求开发队伍水平较高。



## 第三章 需求分析

确定系统必须具有的**功能和性能**，系统要求的**运行环境**，并且预测系统发展的前景。

换句话说需求就是以一种清晰、简洁、一致且无二义性的方式，对一个待开发系统中各个有意义方面的陈述的一个集合。

1. 需求获取
2. 需求分析
3. 需求描述
4. 需求验证
5. 需求更改

### 需求提炼（分析）

对应用问题及环境的理解和分析，为问题涉及的**信息、功能及系统行为建立模型**。将用户需求**精确化、完全化**，最终形成**需求规格说明书**。

* 结构化分析模型
* 面向对象分析模型

#### 需求建模图形工具

|      | 面向过程的需求分析             | 面向对象的需求分析   |
| ---- | --------------------- | ----------- |
| 数据模型 | 实体-联系图（ERD）  数据字典（DD） | 类图、类关系图     |
| 功能模型 | 数据流图（DFD）             | 用例图         |
| 行为模型 | 状态变迁图（STD）            | 活动图、时序图、状态图 |

#### 面向过程分析方法

功能模型--数据流图DFD

数据模型--ER图，数据字典

行为模型--状态变迁图STD

#### 面向对象分析方法UML

功能模型--用例图

数据模型--类图

行为模型--活动图、时序图、状态图等



## 第四章 系统设计

软件设计定义为**软件系统或组件的架构、构件、接口和其他特性的定义过程及该过程的结果。**

**概要设计**

描述软件的顶层架构和组织，划分不同的组件。解决系统总体上应该如何做，即将分析模型映射为具体的软件结构。

**详细设计**

详细设计则将概要设计的结果具体化，详细描述各组件以便能够编码实现 。

### 抽象

忽略具体的信息将不同事物看成相同事物的过程

### 体系结构

软件的整体结构和这种结构为系统提供概念上完整性的方式

软件设计的目标之一就是导出系统的体系结构图，该图作为一个框架，将指导更为详细的设计活动。

### 模块化

软件被划分为命名和功能相对独立的多个组件（通常称为模块），通过这些组件的集成来满足问题的需求

### 信息隐藏

模块定义和设计时应当保证模块内的信息（过程和数据）不可以被不需要这些信息的其他模块访问 

### 功能独立 

每个模块只解决了需求中特定的子功能，并从程序结构的其他部分看该模块具有简单的接口 

- 内聚性：模块的功能相对强度
- 耦合性：模块之间的相互依赖程度 

---

### 结构化组件设计

任何程序总可以用三种结构化的构成元素来设计和实现

- 顺序：任何算法规约中的核心处理步骤
- 条件：允许根据逻辑情况选择处理的方式
- 重复：提供了循环

详细设计工具可以分为以下三类：

- 图形设计符号：流程图、盒图等
- 表格设计符号：决策表等
- 程序设计语言：PDL等

### 面向对象设计

**实体类**

实体类用于对必须**存储的信息和相关行为**进行建模

实体类源于业务模型中的业务实体，但出于对系统结构的优化，可以在后续的过程中被分拆、合并

**边界类**

**参与者与用例**之间应当建立边界类

用例与用例之间如果有交互，应当为其建立边界类

如果用例与系统边界之外的非人对象有交互，应当为其建立边界类

在相关联的业务对象有明显的独立性要求，即它们可能在各自的领域内发展和变化，但又希望互不影响时，也应当为它们建立边界类

**控制类**

控制类来源于对用例场景中**动词的分析和定义**



## 第六章 质量保证



## 第七章 软件维护



## 第八章 项目管理

